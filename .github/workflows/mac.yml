name: Build macOS

permissions:
  contents: read
  pull-requests: write
  
on:
  workflow_dispatch:
    inputs:
      AVR_RUN_ID:
        required: true
        type: string
  workflow_call:
    inputs:
      AVR_RUN_ID:
        required: true
        type: string
  push:
  pull_request:
  

jobs:
  build-dmg:
    runs-on: macos-15-intel
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download firmware from most recent continuous release
        if: ${{github.event_name != 'workflow_dispatch'}}
        run: |
          HEX_URL=$(gh api graphql -f query='query {repository ( owner : "brentfpage", name: "Labrador") {release ( tagName: "continuous" ) {releaseAssets(first:10) {nodes {downloadUrl}}}}}' | jq '.data.repository.release.releaseAssets.nodes[] | select(.downloadUrl| test("02.hex")) | .[]')
          wget $HEX_URL
        env:
          GH_TOKEN: ${{ github.token }}

# better alternative to the graphql query above would be to somehow retrieve the run-id of the most recent continuous.yml workflow run, then download the hex asset associated with the run-id using actions/download-artifact.
# query description: get at most 10 assets from the most recent continuous release (assume there are fewer than 10), find the one that includes 02.hex in the download url
# prettified (ish) query:
# query {\
#         repository ( owner : "espotek-org", name: "Labrador") {\
#           release ( tagName: "continuous" ) {\
#             releaseAssets(first:10) {\
#               nodes {\
#                 downloadUrl\
#               }\
#             }\
#           }\
#         }\
#       }\
# ' --jq '.data.repository.release.releaseAssets.nodes[] | select(.downloadUrl| test("02.hex")) | .[]'

      - name: Download firmware from in-process continuous release
        if: ${{github.event_name == 'workflow_dispatch'}}
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ inputs.AVR_RUN_ID }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: move firmware to appropriate directory
        run: |
          mv asset-hex/*02.hex Desktop_Interface/resources/firmware

      - name: Setup Homebrew dependencies
        run: |
          brew update
          brew remove --force $(brew list --formula) || true
          brew install fftw libomp qt@5 libusb eigen create-dmg
          brew link libomp qt@5 --force

      - name: Build librador
        working-directory: Librador_API/___librador/librador
        run: |
          qmake -config release
          make -j$(sysctl -n hw.ncpu)

      - name: Build librademo
        working-directory: Librador_API/___librador/librademo
        run: |
          qmake -config release
          make -j$(sysctl -n hw.ncpu)

      - name: Build basicdemo
        working-directory: Librador_API/___librador/basicdemo
        run: |
          qmake -config release
          make -j$(sysctl -n hw.ncpu)

      - name: Import code signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          # Create keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo -n "$MACOS_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Build macOS app
        working-directory: Desktop_Interface
        run: |
          qmake -config release
          make -j$(sysctl -n hw.ncpu)
          macdeployqt Labrador.app -verbose=2 -libpath=build_mac/libdfuprog/lib/

      - name: Code sign app bundle
        working-directory: Desktop_Interface
        run: |
          # Find the signing identity
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          echo "Using signing identity: $IDENTITY"
          
          # Sign all frameworks and dylibs first
          find Labrador.app/Contents/Frameworks -name "*.dylib" -o -name "*.framework" | while read file; do
            codesign --force --timestamp --options runtime --sign "$IDENTITY" "$file" || true
          done
          
          # Sign the main app bundle
          codesign --force --deep --timestamp --options runtime --sign "$IDENTITY" Labrador.app
          
          # Verify the signature is valid (but don't check Gatekeeper yet - app isn't notarized)
          codesign -vv --deep --strict Labrador.app
          echo "App bundle signed successfully"

      - name: Create and sign DMG
        working-directory: Desktop_Interface
        run: |
          # Get the git hash for the filename
          GIT_HASH=$(git rev-parse --short HEAD)
          
          # Find the signing identity
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          
          # Create a beautiful DMG with:
          # - Applications folder symlink for drag-and-drop
          # - Custom window size and icon positions
          # - App icon extracted and used as DMG icon
          create-dmg \
            --volname "Labrador" \
            --volicon "Labrador.app/Contents/Resources/iconfile.icns" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "Labrador.app" 175 190 \
            --hide-extension "Labrador.app" \
            --app-drop-link 425 190 \
            --codesign "$IDENTITY" \
            "Labrador-${GIT_HASH}.dmg" \
            "Labrador.app"

      - name: Notarize DMG
        working-directory: Desktop_Interface
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          GIT_HASH=$(git rev-parse --short HEAD)
          DMG_PATH="Labrador-${GIT_HASH}.dmg"
          
          # Submit for notarization
          echo "Submitting DMG for notarization..."
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
          
          # Staple the notarization ticket to the DMG
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          
          # Verify notarization
          echo "Verifying notarization..."
          xcrun stapler validate "$DMG_PATH"
          spctl -a -vvv -t install "$DMG_PATH"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: asset-dmg
          path: Desktop_Interface/Labrador*.dmg
          compression-level: 0
          if-no-files-found: error
